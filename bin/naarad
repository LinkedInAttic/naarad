#!/usr/bin/env python
# coding=utf-8
"""
Â© 2013 LinkedIn Corp. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
 
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
"""

import argparse
import ConfigParser
import errno
import logging
import os
import sys
import threading

# Add src directory to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'src')))

import naarad.utils
from naarad.metrics.metric import Metric
from naarad.metrics.gc_metric import GCMetric
from naarad.metrics.innotop_metric import INNOMetric
from naarad.metrics.sar_metric import SARMetric
from naarad.graphing import dygraphs
from naarad.reporting.report import Report
from naarad.reporting.diff import Diff, NaaradReport
from naarad.run_steps.run_step import Run_Step
from naarad.run_steps.local_cmd import Local_Cmd
import naarad.naarad_constants as CONSTANTS
import time

try:
  from naarad.naarad_imports import metric_classes, graphing_modules, device_type_metrics
except ImportError:
  metric_classes = {}
  graphing_modules = {}

#Naarad pre-defined
metric_classes['GC'] = GCMetric
metric_classes['SAR'] = SARMetric
metric_classes['INNOTOP'] = INNOMetric

graphing_modules['dygraphs'] = dygraphs
graphing_modules['js'] = dygraphs
graphing_modules['javascript'] = dygraphs

Metric.graphing_modules = graphing_modules
Metric.device_types = device_type_metrics

version = "0.1"

template_dir = os.path.abspath(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'templates'))
template_urls = {
    "template:gc": os.path.join(template_dir,"config-gc"),
    "template:sar": os.path.join(template_dir,"config-sar"),
    "template:innotop": os.path.join(template_dir,"config-inno")
    }

logger = logging.getLogger('naarad')

# tracks the number of SLA failures
sla_failures = 0

def init_logging(log_level):
  log_file = 'naarad.log'
  # clear the log file
  with open(log_file, 'w'):
    pass

  numeric_level = getattr(logging, log_level.upper(), None) if log_level else logging.INFO
  if not isinstance(numeric_level, int):
    raise ValueError('Invalid log level: %s' % log_level)
  
  logger.setLevel(logging.DEBUG)
  fh = logging.FileHandler(log_file)
  fh.setLevel(logging.DEBUG)
  ch = logging.StreamHandler()
  ch.setLevel(numeric_level)
  formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
  fh.setFormatter(formatter)
  ch.setFormatter(formatter)
  logger.addHandler(fh)
  logger.addHandler(ch)

def read_naarad_templates():
  """
    Read $HOME/.naarad/templates.txt file to read user-defined template keys and related URLs
  """
  home_directory = os.getenv('HOME')
  template_file = os.path.join(home_directory, '.naarad', 'templates.txt')
  logger.info('Adding templates from: ' + template_file)
  if os.path.exists(template_file):
    with open(template_file,'r') as FH:
      for line in FH:
        template, url = [word.strip() for word in line.split()]
        if naarad.utils.is_valid_url(url):
          logger.warning('This line in .naarad/templates.txt does not contain correct URL.' + line + '. Continuing.')
          continue
        if not template.startswith('template:'):
          logger.warning('Template name in this line in .naarad/templates.txt does not follow the convention. Start the name with "template:" please.')
          continue
        if template in template_urls:
          logger.info('Template ' + template + ' exists as pre-defined in Naarad. Overriding the pre-defined template name.')
        logger.info('Adding template ' + template) 
        template_urls[template] = url

def parse_and_plot_single_metrics(metric, graph_timezone, outdir_default, indir_default, graphing_library, graph_lock):
  metric.graph_timezone = graph_timezone
  if metric.outdir is None:
    metric.outdir = os.path.normpath(outdir_default)
    
  # handling both cases of local file or http download. 
  if not metric.infile.startswith('http://')  \
    and not metric.infile.startswith('https://'): 
    metric.infile = os.path.join(indir_default, metric.infile)
    
  if not metric.ignore:
    if metric.collect():
      if metric.parse():
        metric.calc()
        metric.calculate_stats() 
        global sla_failures
        sla_failures = sla_failures + metric.check_slas()
        graph_lock.acquire()
        metric.graph(graphing_library)
        graph_lock.release()
      else:
        logger.error('Parsing failed for metric: '  + metric.label)
    else:
      logger.error('Fetch/Collect failed for metric: ' + metric.label)

def print_usage():
  print ("Usage: "
               "\n To generate a diff report      : naarad -d report1 report2 -o <output_location>"
               "\n To generate an analysis report : naarad -i <input_location> -o <output_location> -c <config_file>")

def get_config_file(arg):
  """
    Helper function to extract the config file from arguments
  """
  # Download config if its a URL
  if naarad.utils.is_valid_url(arg):
    optf = naarad.utils.download_file(arg)
  elif arg.startswith("template:"):
    #Its a template
    if arg in template_urls.keys():
      logger.info('Using template ' + arg + ' used from ' + template_urls[arg] )
      optf = naarad.utils.download_file(template_urls[arg])
    else:
      sys.exit("ERROR: Template " + arg + " not found. Exiting...")
    with open(optf, 'r') as FH:
      print "Config file used looks like this:"
      print "-------------"
      print FH.read()
      print "-------------"
  else:
    optf = arg
  if not os.path.exists(optf):
    sys.exit("ERROR: Config file " + optf + " doesn't exist. If this is a URL, please use the fully qualified domain name\nExiting....")
  return optf  

def main():
  metrics = []
  crossplots = []
  run_steps = []
  graph_timezone = None
  graphing_library = 'matplotlib'
  variables_dict = {}
  bin_path = os.path.dirname( __file__ )

  arg_parser = argparse.ArgumentParser()
  arg_parser.add_argument('-c', '--config', help="file with specifications for each metric and graphs")
  arg_parser.add_argument('-i', '--input_dir', help="input directory used to construct full path name of the metric infile")
  arg_parser.add_argument('-o', '--output_dir', help="output directory where the plots and Report.html will be generated")
  arg_parser.add_argument('-r', '--resource_path', help="output sub-directory where resources such as images/svg/csv etc will be stored", default='resources')
  arg_parser.add_argument('-V', '--variables', action="append", help="User defined variables (in form key=value) for substitution in the config file. Config should have the variable names in format %%(key)s")
  arg_parser.add_argument('-s', '--show_config', help="Print config associated with the provided template name", action="store_true")
  arg_parser.add_argument('-l', '--log', help="log level")
  arg_parser.add_argument('-d', '--diff', nargs=2, help="Specify the location of two naarad reports to diff separated by a space. Can be local or http(s) locations. The first report is used as a baseline.", metavar=("report-1", "report-2"))
  arg_parser.add_argument('-e', '--exit_code', help="optional argument to enable exit_code for naarad", action="store_true")
  #TODO(Ritesh) : Print a list of all templates supported with descriptions
  #arg_parser.add_argument('-l', '--list_templates', help="List all template configs", action="store_true")

  args = arg_parser.parse_args()

  init_logging(args.log)

  if args:
    if args.diff:
      if not args.output_dir:
        logger.error('No Output location specified')
        print_usage()
      else:
        diff_report = Diff([NaaradReport(args.diff[0], None), NaaradReport(args.diff[1], None)], 'diff', args.output_dir, os.path.join(args.output_dir, args.resource_path), args.resource_path)
        if args.config:
          diffoptfile = get_config_file(args.config)
          diff_report.extract_sla_from_config_file(diffoptfile)
        diff_report.generate()
      if diff_report.sla_failures > 0:
        sys.exit(CONSTANTS.SLA_FAILURE)
      sys.exit(0)   
    elif not args.config:
      print_usage()
      sys.exit(0)
    read_naarad_templates()
    if args.show_config:
      tmp_file = naarad.utils.download_file(template_urls[args.config])
      with open(tmp_file, 'r') as FH:
        print "----"
        print FH.read()
      sys.exit("----")

    optfile = get_config_file(args.config)
    indir_default = args.input_dir
    outdir_default = args.output_dir
    resource_path = args.resource_path
    #user defined variables in form "key=value"
    if args.variables:
      for var in args.variables:
        words = var.split('=')
        variables_dict[words[0]] = words[1]

    # Parse the config file
    # TODO: Refactor the config parsing code
    config_obj = ConfigParser.ConfigParser(variables_dict)
    # Preserve case http://stackoverflow.com/questions/1611799/preserve-case-in-configparser
    config_obj.optionxform = str
    config_obj.read(optfile)
    for section in config_obj.sections():
      # GRAPH section is optional
      if section == 'GRAPH':
        graphing_library, crossplots, outdir_default, indir_default, graph_timezone = \
          naarad.utils.parse_graph_section(config_obj, section, outdir_default, indir_default)
      elif section.startswith('RUN-STEP'):
        run_steps.append(naarad.utils.parse_run_step_section(config_obj, section))
      else:
        # section name is used to create sub-directories, so enforce it. 
        if not naarad.utils.is_valid_metric_name(section):
          logger.critical('Section name %s is invalid! Only letters, digits, dot(.), dash(-), underscore(_) are allowed' % section)
          sys.exit(0)
        if section == 'SAR-*':
          hostname, infile, label, ts_start, ts_end, precision, kwargs, rule_strings = \
            naarad.utils.parse_basic_metric_options(config_obj, section)
          sar_metrics = naarad.utils.get_all_sar_objects(metrics, infile, hostname, outdir_default, label, ts_start,
                                                         ts_end, None)
          if config_obj.has_option(section, 'ignore') and config_obj.getint(section, 'ignore') == 1:
            for metric in sar_metrics:
              metric.ignore = True
          metrics.extend(sar_metrics)
        else:
          new_metric = naarad.utils.parse_metric_section(config_obj, section, metric_classes, outdir_default, resource_path)
          new_metric.bin_path = bin_path
          metrics.append(new_metric)

    if outdir_default:
      try:
        os.makedirs(outdir_default)
      except OSError as exception:
        if exception.errno != errno.EEXIST:
          raise
      try:
        resource_directory = os.path.join(outdir_default, resource_path)
        os.makedirs(resource_directory)
      except OSError as exception:
        if exception.errno != errno.EEXIST:
          raise
      logger.info('Report.html and the plots will be in ' + outdir_default)
    else:
      sys.exit("No output directory defined. Please use option -o, or update the config. Exiting...")

    if graph_timezone:
      logger.info('X-axis will be displayed in timezone: %s', graph_timezone)
    threads = []
    #TODO: Implement ordering of run_steps
    for run_step in run_steps:
      run_step.run()
    ts_start, ts_end = naarad.utils.get_run_time_period(run_steps)
    graph_lock = threading.Lock()
    for metric in metrics:
      if ts_start:
        metric.ts_start = ts_start
      if ts_end:
        metric.ts_end = ts_end
      thread = threading.Thread(target=parse_and_plot_single_metrics, args=(metric, graph_timezone, outdir_default, indir_default, graphing_library, graph_lock))
      thread.start()
      threads.append(thread)
    for t in threads:
      t.join()
    if len(crossplots) > 0:
      correlated_plots = naarad.utils.nway_plotting(crossplots, metrics, resource_directory, resource_path)
    else:
      correlated_plots = []
    rpt = Report(None, outdir_default, resource_directory, resource_path, metrics, correlated_plots=correlated_plots)
    rpt.generate()

  global sla_failures  
  if args.exit_code:
    if sla_failures > 0: 
      sys.exit(CONSTANTS.SLA_FAILURE)

if __name__ == '__main__':
  main()
